\chapter{Resultados obtenidos y trabajos futuros}
\section{Casos de uso}
\subsection{Stacked Borrows y Análisis de cabecera de funciones}
Nuestra herramienta utiliza Stacked Borrows y un análisis dedicado a los enunciados de las funciones para detectar errores de aliasing. Esto lo podemos apreciar en el siguiente ejemplo.

\begin{lstlisting}[
    language=Rust,
    label=code:example1,
    caption={Ejemplo1 mostrado en el paper Stacked Borrows \citep{stackedborrows}}
]
fn main() {
    let mut local = 5;
    let raw_pointer = &mut local as *mut i32;
    let result = unsafe { example1(&mut *raw_pointer, &mut *raw_pointer) };
    println!("{}", result); // Prints "13".
}

fn example1(x: &mut i32, y: &mut i32) -> i32 {
    *x = 42;
    *y = 13;
    return *x; // Has to read 42 , because x and y cannot alias !
}
\end{lstlisting}

Al comienzo de la función \textit{main()} podemos apreciar la declaración de una variable mutable(local) y un puntero raw(raw\_pointer) que hará referencia a la misma. Luego se invoca la función \textit{example1}, la cual toma como argumentos formales 2 referencias mutables, utilizando la referencia al puntero raw en ambos argumentos. Aquí es donde surgen los problemas. Primero, si bien no esta contemplado por Stacked Borrows, al llamar una función con más de una referencia mutable indica que la implementación del código puede no ser correcta. Y segundo, el problema que trata de atacar Stacked Borrows, es el grave problema de aliasing que surge cuando ambos argumentos tratan de modificar los valores de sus referencias, cuando están apuntando a una misma variable.

Para resolver el primer problema, nuestra herramienta analiza la cabecera de las funciones que son llamadas. Mediante este análisis comprobamos que no existan dos o más referencias mutables apuntando a una misma variable a la hora de la invocación. Si los argumentos formales incluyen dos o más referencias mutables se muestra un mensaje ``Caution'' ya que puede llegar a generar problemas si no se toman las medidas de seguridad necesarias para la comprobación de los parámetros. Y en el caso de que existan dos o más referencias mutables que hacen referencia a una misma variable, es decir que exista aliasing, se muestra un mensaje de ``Warning'' porque es un gran indicativo de que pueden generarse errores debido a esto. Esto lo podemos apreciar en \href{run:../src/mir_visitor/terminator_visitor.rs}{terminator\_visitor.rs} entre las lineas 33-50.

El segundo problema se resuelve mediante la implementación de Stacked Borrows. Generamos una pila donde iremos agregando las variables y referencias a medida que se van creando, y mortificándola cada vez que se produce una modificación a las mismas. Mediante esta pila simularemos el trabajo del borrow checker para determinar el tiempo de vida de las variables, extendiéndolo de tal manera que el análisis soporte tanto programas safe como unsafe.
De esta manera, cada vez que la pila se modifica se realiza un chequeo para comprobar si existen referencias mutables X e Y tales que se encuentren ordenadas ``XYXY'' en la pila. Esto indicaría una violación de los principios de Stacked Borrows, y por lo tanto, se muestra un ``Error''. Estos errores pueden ser que la variable no tenia permisos para escribir o leer, dependiendo del caso. En el ejemplo, en la función \textit{example1()} podemos ver como romper el principio de la pila genera errores. Queremos retornar 42 en la variable X, pero como existe aliasing y se realiza una escritura de la forma ``XYX'', el valor a retornar es diferente. Por lo tanto existe un error ya que la variable Y no debería haber tenido permitido escribir. Una posible solución seria cambiar los accesos para que queden de forma ``YXXY'', de esta manera no se rompen los principios establecidos y el programa seria considerado correcto.

En el siguiente fragmento de la salida de nuestra herramienta podemos apreciar estos mensajes indicativos dentro de la información del MIR.

\begin{lstlisting}[language=Rust]
Main body -- Start
Block Main bb0 --Start

use bb0[0] Assign local = const 5_i32
bb0[1] Assign 3 = &mut _1 ref local
bb0[2] Assign raw_pointer = &raw mut (*_3) ref 3
bb0[3] Assign 6 = &mut (*_2) ref raw_pointer
bb0[4] Assign 5 = &mut (*_6) ref 6
bb0[5] Assign 8 = &mut (*_2) ref raw_pointer
bb0[6] Assign 7 = &mut (*_8) ref 8
bb0[7] Terminator _4 = example1(move _5, move _7) -> bb1
        where _4 is result
        and _5 is 5     and _7 is 7
call example1
Caution: This function call contains two or more mutable arguments
WARNING: Calling function with two mutable arguments that are alias
const ty for<'r, 's> fn(&'r mut i32, &'s mut i32) -> i32 {example1}

Example1 body -- Start

Block Example1 bb0 --Start

use bb0[0] Assign x = const 42_i32
use ERROR Tag "y" does not have WRITE access
bb0[1] Assign y = const 13_i32
use ERROR Tag "x" does not have READ access
bb0[2] Assign 0 = (*_1) ref x
bb0[3] Terminator return

Block Example1 bb0 --End
Example1 body -- End
\end{lstlisting}

\subsection{Análisis de cast}
Mediante el uso de unsafe podemos realizar casts de un tipo determinado a otro diferente, el cual ni siquiera tenga la misma representación o al menos use una representación que tenga una cantidad de bytes equivalente. Esta utilización puede resultar en comportamiento indefinido. Un ejemplo de este mecanismo lo podemos encontrar en el ejemplo:

\begin{lstlisting}[
    language=Rust,
    label=code:cast_example,
    caption={Ejemplo de casteo de una variable a otra con diferente representación.}
]
pub fn main() {
    let mut one: u64 = 5;
    let raw = &mut one as *mut u64;
    let raw2 = raw as *mut u32;
    unsafe {
        let two = *raw2;
    }
}
\end{lstlisting}

En este ejemplo podemos apreciar como declaramos una variable llamada \textit{one}, que es del tipo u64 y tiene una representación en 8 bytes. Luego creamos dos punteros raw, donde el primero hace referencia a la primer variable manteniendo su representación de u64. Sin embargo, en el segundo puntero (raw2), se crea a partir de raw y utilizando como base el tipo u32, que tiene una representación de 4 bytes y es diferente. En la siguiente instrucción dentro del bloque unsafe hacemos uso del valor dentro de raw2 colocandolo dentro de una variable nueva llamada \textit{two}.\\
Esto es un problema grave, ya que la nueva variable \textit{two} tiene dentro información que probablemente no sea correcta, ya que hicimos un casteo que no debería ser posible si utilizáramos unicamente referencias dentro de safe Rust. Estamos realizando una transformación de una variable u64 a una u32 que tiene una representación no solo diferente, sino que 4bytes menor, de una manera insegura y el contenido probablemente sea inconsistente y produzca comportamiento indeseado en el programa.

Nuestra herramienta detecta estas situaciones mediante la comparación del tamaño de la representación de ambas partes de un cast. Si el tamaño es igual o mayor no hay necesidad de mostrar ningún mensaje de error. Pero cuando queremos hacer una transformación a una representación menor, es muy probable que suframos de perdida de información; y por este motivo nuestro analizador lo detecta y envía un mensaje informando de la situación. Esto lo podemos observar programado en el archivo \href{run:../src/mir_visitor/block_visitor.rs}{block\_visitor.rs} entre las lineas 122-150

En el output a continuación se observa el mensaje de Warning asociado a este caso.

\begin{lstlisting}[language=rust]
Main body -- Start
Block Main bb0 --Start

use bb0[0] Assign one = const 5_u64
bb0[1] Assign 3 = &mut _1 ref one
bb0[2] Assign raw = &raw mut (*_3) ref 3
use bb0[3] Assign 5 = _2 ref raw
kst WARNING: Casting from a layout with 8 bits to 4 bits
from *mut u64 to *mut u32
bb0[4] Assign raw2 = move _5 as *mut u32 (Misc) ref 5
use bb0[5] Assign two = (*_4) ref raw2
bb0[6] Terminator return

Block Main bb0 --End
Main body -- End
\end{lstlisting}

\subsection{Points to alias analysis}
Otro apartado importante en el cual se enfoca nuestro proyecto es en el análisis interprocedural de alias. Mediante el uso de points-to en conjunto con los lifetimes obtenidos gracias al stack de Stacked Borrows, podemos obtener un grafo de aliasing que nos brinda información adicional para detectar errores.

\begin{lstlisting}[
    language=Rust,
    label=code:points_to,
    caption={Ejemplo de un programa el cual le aplicamos analisis de alias points-to \citep{interprocedural}}
]
fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        let res = *r1 + *r2;
    }
}
\end{lstlisting}

En este fragmento de código podemos ver como se declara una variable mutable \textit{num}, y se crean dos punteros raw que hacen referencia a esta (\textit{r1} y \textit{r2}). Luego se genera una variable \textit{res} que contendrá el valor resultante de la suma de los valores apuntados por \textit{r1} y \textit{r2}, que al ser raw pointers, para ser derreferenciados deben estar dentro de un bloque unsafe.

En este ejemplo, Stacked Borrows no genera ningún error o advertencia, ya que el programa es válido. Sin embargo, sigue existiendo aliasing y esto puede representar un problema a futuro si se llegase a modificar el código. Ahi es donde entra nuestro points-to análisis, que genera un grafo de alias a medida que se construye el programa y una vez terminado, lo observa para buscar potenciales problemas de alias. Si encuentra alguno, lo reporta por pantalla al finalizar el análisis de cada una de las funciones. Además, gracias a Stacked Borrows podemos saber si esa misma variable esta viva o muerta, y en caso de que se encuentre en este ultimo estado, también lo mencionamos por pantalla.

En la salida de la ejecución de nuestra herramienta podemos observar como nos advierte del posible problema de aliasing de \textit{num} y mediante la vista una parte del grafo (utiliza formato DOT) vemos cuales son las variables definidas por el usuario y auxiliares que apuntan a \textit{num}

\begin{minipage}[c][10cm][c]{0,5\textwidth}
\begin{lstlisting}[language=Rust]
Block Main bb1 --End
Main body -- End

Variable num may have aliasing
digraph {
    0 [ label = "num"]
    1 [ label = "3"]
    2 [ label = "r1"]
    3 [ label = "5"]
    4 [ label = "r2"]
    5 [ label = "7"]
    6 [ label = "8"]
    7 [ label = "9"]
    8 [ label = "_res"]
    1 -> 0 [ ]
    2 -> 1 [ ]
    3 -> 0 [ ]
    4 -> 3 [ ]
    8 -> 7 [ ]
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[c][9cm][t]{0,5\textwidth}
\begin{center}
	\begin{tikzpicture}
	    \begin{dot2tex}[tikz,options=-t math,scale=1.3]
	    digraph {
	        0 [ label = "num"]
	        1 [ label = "3"]
	        2 [ label = "r1"]
	        3 [ label = "5"]
	        4 [ label = "r2"]
	        1 -> 0 [ ]
	        2 -> 1 [ ]
	        3 -> 0 [ ]
	        4 -> 3 [ ]
	    }
	    \end{dot2tex}
	\end{tikzpicture}
\end{center}
\end{minipage}
